# Price Level ML

Этот проект направлен на обнаружение уровней цен в данных о торговле криптовалютами с использованием методов машинного обучения. Проект получает исторические данные с Bybit, обрабатывает их и обучает модель для выявления значительных уровней цен.

## Сбор данных

Проект начинает с получения исторических данных о торговле криптовалютами с платформы Bybit. Это может включать такие данные, как цены открытия, закрытия, максимальные и минимальные цены, объемы торгов и временные метки.

## Предобработка данных

Полученные данные проходят этап предобработки. Это может включать:

- Очистку данных: удаление или обработка пропущенных значений.
- Нормализацию данных: приведение данных к единому масштабу.
- Создание дополнительных признаков: например, вычисление скользящих средних, индикаторов технического анализа и других признаков, которые могут помочь модели лучше понять данные.

## Обучение модели

После предобработки данные используются для обучения модели машинного обучения. В зависимости от задачи, это может быть регрессионная модель, модель классификации или другая подходящая модель. Модель обучается на исторических данных, чтобы выявить значительные уровни цен, такие как уровни поддержки и сопротивления.

## Оценка модели

После обучения модель оценивается на тестовых данных, которые не использовались в процессе обучения. Это позволяет понять, насколько хорошо модель справляется с задачей на новых данных. Метрики оценки могут включать точность, полноту, F1-меру и другие показатели, в зависимости от типа модели и задачи.

## Прогнозирование

Обученная и оцененная модель используется для прогнозирования значительных уровней цен на новых данных. Это может помочь трейдерам принимать более обоснованные решения на основе выявленных уровней цен.

## Визуализация результатов

Результаты работы модели могут быть визуализированы для удобства анализа. Это может включать графики с историческими данными и отмеченными уровнями цен, которые модель считает значительными.

## Структура проекта

- .env
- .gitignore
- data/
- processed/
- raw/
- mlruns/
- README.md
- requirements.txt
- src/
- notebooks/

## Установка

```sh
git clone https://github.com/actualusername/actual-repo.git
cd pricelevel-ml
python -m venv venv
# Activate the virtual environment
# On macOS/Linux:
source venv/bin/activate
# On Windows:
venv\Scripts\activate
pip install -r requirements.txt
```

## Конфигурация

Обновите файл .env вашими учетными данными API Bybit и другими параметрами конфигурации.

```sh
python src/data_fetcher.py  # This script fetches historical cryptocurrency trading data from Bybit.
python src/main.py  # This script runs the entire pipeline including data preprocessing, model training, and evaluation.
```

## Модули проекта

- `src/config.py`: Параметры конфигурации для проекта.
- `src/data_fetcher.py`: Функции для получения исторических данных с Bybit.
- `src/dataset.py`: Класс Dataset для подготовки данных к обучению.
- `src/cluster_levels.py`: Функции для нахождения и кластеризации локальных экстремумов в данных о ценах.
- `src/train.py`: Функции для обучения и оценки модели.
- `src/main.py`: Основной скрипт для запуска всего пайплайна.
- `notebooks/`: Jupyter Notebooks для анализа данных и экспериментов.

## Лицензия

Этот проект лицензирован по лицензии MIT. Полный текст лицензии можно найти по [этой ссылке](https://opensource.org/licenses/MIT).

### Пояснения к логике

**Мультитаймфрейм:**

- Основной анализ уровней ведётся на дневных данных.
- Дополнительные проверки (скорость подхода, объёмы, ретест и т.д.) делаются на 4H и 1H.
- При желании, можно в фильтре (filter_levels) глубже анализировать поведение цены (ложный пробой, сильный отбой, растущие объёмы при поджатии и т.п.).

**ATR:**

- Рассчитываем на дневном ТФ.
- Параметр atr_buffer (10-15% от ATR) определяет «зону допуска» к уровню, которую можно считать касанием.

**Фильтрация уровней:**

- Минимальное количество касаний (touches).
- «Возраст» уровня (сколько дней прошло с последнего касания). Если слишком много — уровень «протух».
- «Свободная зона» (см. пример, где проверяем max_high_since_touch - lvl > 1.0 * ATR).
- Анализ 4H/1H (объёмы, скорость подхода, глубина отскока). В примере это условно показано через avg_4h_volume > volume_factor * ....

**Backtest:**

- Код run_backtest и plot_backtest_results остаётся простым.
- Чтобы протестировать именно пробой или ложный пробой, придётся доработать логику сигналов (signal=+1 / -1) в main.py.

**Универсальность:**

- Код можно адаптировать для любого инструмента (Forex, Crypto, Stocks), лишь бы data_fetcher мог подтянуть нужные OHLCV-данные (open, high, low, close, volume) на нескольких таймфреймах.

### Что дальше улучшить

- Более точное определение ложного пробоя: например, смотреть, как много свечей закрылись за уровнем, есть ли резкие фитили, как быстро цена возвращается обратно и т.д.
- Расширенный учёт объёмов: сравнивать объёмы не просто со средним за весь период, а со средним за аналогичный временной интервал (rolling window).
- Умная кластеризация уровней (разделять уровни поддержек и сопротивлений, считать их «силу»).
- Улучшенная логика сигналов в бэктесте (пробой/отбой, лимитные входы, стоп-лоссы за уровнем и т.д.).
- Дополнительно: можно записывать результаты в MLflow, чтобы автоматически сравнивать разные параметры фильтра и видеть, как меняется доходность на бэктесте.

### Итог

Таким образом, вы получаете мультитаймфреймовый анализ, в котором:

- Дневной таймфрейм – базовый для поиска уровней и расчёта ATR.
- 4H/1H – подтверждающие, чтобы учесть скорость подхода, поджатие, ретесты, объёмы.

На выходе — набор отфильтрованных уровней, которые не слишком старые, имеют несколько касаний, достаточную консолидацию и близость закрытия без глубоких фитилей. Далее для бэктеста уровни рисуются горизонтальными линиями, а сигналы (пробой, отбой, ложный пробой) можно формализовать и проверить на истории. Вся описанная логика — «скелет», который в реальном проекте потребуется детализировать и настраивать под конкретные торговые идеи.
